<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>ActiveRecord::Transactions::ClassMethods</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link rel="stylesheet" href="../../../css/reset.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../css/main.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../css/github.css" type="text/css" media="screen" />
<script src="../../../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../js/jquery-effect.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../js/main.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../js/highlight.pack.js" type="text/javascript" charset="utf-8"></script>

</head>

<body>     
    <div class="banner">
        
        <h1>
            <span class="type">Module</span> 
            ActiveRecord::Transactions::ClassMethods 
            
        </h1>
        <ul class="files">
            
            <li><a href="../../../files/activerecord/lib/active_record/transactions_rb.html">activerecord/lib/active_record/transactions.rb</a></li>
            
        </ul>
    </div>
    <div id="bodyContent">
        <div id="content">
  
    <div class="description">
      
<p><a href="../Transactions.html">Transactions</a> are protective blocks where
SQL statements are only permanent if they can all succeed as one atomic
action. The classic example is a transfer between two accounts where you
can only have a deposit if the withdrawal succeeded and vice versa. <a
href="../Transactions.html">Transactions</a> enforce the integrity of the
database and guard the data against program errors or database break-downs.
So basically you should use transaction blocks whenever you have a number
of statements that must be executed together or not at all. Example:</p>

<pre>ActiveRecord::Base.transaction do
  david.withdrawal(100)
  mary.deposit(100)
end</pre>

<p>This example will only take money from David and give to Mary if neither
<code>withdrawal</code> nor <code>deposit</code> raises an exception.
Exceptions will force a ROLLBACK that returns the database to the state
before the transaction was begun. Be aware, though, that the objects will
<em>not</em> have their instance data returned to their pre-transactional
state.</p>

<h2 id="label-Different+Active+Record+classes+in+a+single+transaction">Different Active Record classes in a single transaction</h2>

<p>Though the transaction class method is called on some Active Record class,
the objects within the transaction block need not all be instances of that
class. This is because transactions are per-database connection, not
per-model.</p>

<p>In this example a <code>Balance</code> record is transactionally saved even
though <code>transaction</code> is called on the <code>Account</code>
class:</p>

<pre>Account.transaction do
  balance.save!
  account.save!
end</pre>

<p>Note that the <code>transaction</code> method is also available as a model
instance method. For example, you can also do this:</p>

<pre>balance.transaction do
  balance.save!
  account.save!
end</pre>

<h2 id="label-Transactions+are+not+distributed+across+database+connections"><a href="../Transactions.html">Transactions</a> are not distributed across database connections</h2>

<p>A transaction acts on a single database connection.  If you have multiple
class-specific databases, the transaction will not protect interaction
among them.  One workaround is to begin a transaction on each class whose
models you alter:</p>

<pre>Student.transaction do
  Course.transaction do
    course.enroll(student)
    student.units += course.units
  end
end</pre>

<p>This is a poor solution, but full distributed transactions are beyond the
scope of Active Record.</p>

<h2 id="label-Save+and+destroy+are+automatically+wrapped+in+a+transaction">Save and destroy are automatically wrapped in a transaction</h2>

<p>Both <a href="../Base.html#method-i-save">ActiveRecord::Base#save</a> and
<a href="../Base.html#method-i-destroy">ActiveRecord::Base#destroy</a> come
wrapped in a transaction that ensures that whatever you do in validations
or callbacks will happen under the protected cover of a transaction. So you
can use validations to check for values that the transaction depends on or
you can raise exceptions in the callbacks to rollback, including
<code>after_*</code> callbacks.</p>

<h2 id="label-Exception+handling+and+rolling+back">Exception handling and rolling back</h2>

<p>Also have in mind that exceptions thrown within a transaction block will be
propagated (after triggering the ROLLBACK), so you should be ready to catch
those in your application code.</p>

<p>One exception is the <a href="../Rollback.html">ActiveRecord::Rollback</a>
exception, which will trigger a ROLLBACK when raised, but not be re-raised
by the transaction block.</p>

<p><strong>Warning</strong>: one should not catch <a
href="../StatementInvalid.html">ActiveRecord::StatementInvalid</a>
exceptions inside a transaction block. <a
href="../StatementInvalid.html">StatementInvalid</a> exceptions indicate
that an error occurred at the database level, for example when a unique
constraint is violated. On some database systems, such as PostgreSQL,
database errors inside a transaction causes the entire transaction to
become unusable until it&#39;s restarted from the beginning. Here is an
example which demonstrates the problem:</p>

<pre class="ruby"><span class="ruby-comment"># Suppose that we have a Number model with a unique column called &#39;i&#39;.</span>
<span class="ruby-constant">Number</span>.<span class="ruby-identifier">transaction</span> <span class="ruby-keyword">do</span>
  <span class="ruby-constant">Number</span>.<span class="ruby-identifier">create</span>(:<span class="ruby-identifier">i</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>)
  <span class="ruby-keyword">begin</span>
    <span class="ruby-comment"># This will raise a unique constraint error...</span>
    <span class="ruby-constant">Number</span>.<span class="ruby-identifier">create</span>(:<span class="ruby-identifier">i</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>)
  <span class="ruby-keyword">rescue</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">StatementInvalid</span>
    <span class="ruby-comment"># ...which we ignore.</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># On PostgreSQL, the transaction is now unusable. The following</span>
  <span class="ruby-comment"># statement will cause a PostgreSQL error, even though the unique</span>
  <span class="ruby-comment"># constraint is no longer violated:</span>
  <span class="ruby-constant">Number</span>.<span class="ruby-identifier">create</span>(:<span class="ruby-identifier">i</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>)
  <span class="ruby-comment"># =&gt; &quot;PGError: ERROR:  current transaction is aborted, commands</span>
  <span class="ruby-comment">#     ignored until end of transaction block&quot;</span>
<span class="ruby-keyword">end</span>
</pre>

<p>One should restart the entire transaction if a StatementError occurred.</p>

<h2 id="label-Nested+transactions">Nested transactions</h2>

<p><a href="ClassMethods.html#method-i-transaction">transaction</a> calls can
be nested. By default, this makes all database statements in the nested
transaction block become part of the parent transaction. For example:</p>

<pre class="ruby"><span class="ruby-constant">User</span>.<span class="ruby-identifier">transaction</span> <span class="ruby-keyword">do</span>
  <span class="ruby-constant">User</span>.<span class="ruby-identifier">create</span>(:<span class="ruby-identifier">username</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&#39;Kotori&#39;</span>)
  <span class="ruby-constant">User</span>.<span class="ruby-identifier">transaction</span> <span class="ruby-keyword">do</span>
    <span class="ruby-constant">User</span>.<span class="ruby-identifier">create</span>(:<span class="ruby-identifier">username</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&#39;Nemu&#39;</span>)
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Rollback</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-constant">User</span>.<span class="ruby-identifier">find</span>(:<span class="ruby-identifier">all</span>)  <span class="ruby-comment"># =&gt; empty</span>
</pre>

<p>It is also possible to requires a sub-transaction by passing
<code>:requires_new =&gt; true</code>.  If anything goes wrong, the
database rolls back to the beginning of the sub-transaction without rolling
back the parent transaction. For example:</p>

<pre class="ruby"><span class="ruby-constant">User</span>.<span class="ruby-identifier">transaction</span> <span class="ruby-keyword">do</span>
  <span class="ruby-constant">User</span>.<span class="ruby-identifier">create</span>(:<span class="ruby-identifier">username</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&#39;Kotori&#39;</span>)
  <span class="ruby-constant">User</span>.<span class="ruby-identifier">transaction</span>(:<span class="ruby-identifier">requires_new</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>) <span class="ruby-keyword">do</span>
    <span class="ruby-constant">User</span>.<span class="ruby-identifier">create</span>(:<span class="ruby-identifier">username</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&#39;Nemu&#39;</span>)
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Rollback</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-constant">User</span>.<span class="ruby-identifier">find</span>(:<span class="ruby-identifier">all</span>)  <span class="ruby-comment"># =&gt; Returns only Kotori</span>
</pre>

<p>Most databases don&#39;t support true nested transactions. At the time of
writing, the only database that we&#39;re aware of that supports true
nested transactions, is MS-SQL. Because of this, Active Record emulates
nested transactions by using savepoints. See <a
href="http://dev.mysql.com/doc/refman/5.0/en/savepoints.html">dev.mysql.com/doc/refman/5.0/en/savepoints.html</a>
for more information about savepoints.</p>

<h3 id="label-Caveats">Caveats</h3>

<p>If you&#39;re on MySQL, then do not use DDL operations in nested
transactions blocks that are emulated with savepoints. That is, do not
execute statements like &#39;CREATE TABLE&#39; inside such blocks. This is
because MySQL automatically releases all savepoints upon executing a DDL
operation. When <a
href="ClassMethods.html#method-i-transaction">transaction</a> is finished
and tries to release the savepoint it created earlier, a database error
will occur because the savepoint has already been automatically released.
The following example demonstrates the problem:</p>

<pre class="ruby"><span class="ruby-constant">Model</span>.<span class="ruby-identifier">connection</span>.<span class="ruby-identifier">transaction</span> <span class="ruby-keyword">do</span>                           <span class="ruby-comment"># BEGIN</span>
  <span class="ruby-constant">Model</span>.<span class="ruby-identifier">connection</span>.<span class="ruby-identifier">transaction</span>(:<span class="ruby-identifier">requires_new</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>) <span class="ruby-keyword">do</span>  <span class="ruby-comment"># CREATE SAVEPOINT active_record_1</span>
    <span class="ruby-constant">Model</span>.<span class="ruby-identifier">connection</span>.<span class="ruby-identifier">create_table</span>(<span class="ruby-operator">...</span>)                    <span class="ruby-comment"># active_record_1 now automatically released</span>
  <span class="ruby-keyword">end</span>                                                     <span class="ruby-comment"># RELEASE savepoint active_record_1</span>
                                                          <span class="ruby-comment"># ^^^^ BOOM! database error!</span>
<span class="ruby-keyword">end</span>
</pre>

    </div>
  


  


  
  


  


  
    <!-- Method ref -->
    <div class="sectiontitle">Methods</div>
    <dl class="methods">
      
        <dt>T</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-transaction">transaction</a>
              </li>
            
          </ul>
        </dd>
      
    </dl>
  

  



  

    

    

    


    


    <!-- Methods -->
        
      <div class="sectiontitle">Instance Public methods</div>
      
        <div class="method">
          <div class="title method-title" id="method-i-transaction">
            
              <b>transaction</b>(options = {}, &amp;block)
            
            <a href="../../../classes/ActiveRecord/Transactions/ClassMethods.html#method-i-transaction" name="method-i-transaction" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>See <a
href="ClassMethods.html">ActiveRecord::Transactions::ClassMethods</a> for
detailed documentation.</p>
            </div>
          
          
          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-transaction_source')" id="l_method-i-transaction_source">show</a>
                
              </p>
              <div id="method-i-transaction_source" class="dyn-source">
                <pre><span class="ruby-comment"># File activerecord/lib/active_record/transactions.rb, line 180</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword ruby-title">transaction</span>(<span class="ruby-identifier">options</span> = {}, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-comment"># See the ConnectionAdapters::DatabaseStatements#transaction API docs.</span>
  <span class="ruby-identifier">connection</span>.<span class="ruby-identifier">transaction</span>(<span class="ruby-identifier">options</span>, &amp;<span class="ruby-identifier">block</span>)
<span class="ruby-keyword">end</span></pre>
              </div>
            </div>
            
          </div>
                    </div>

    </div>
  </body>
</html>    